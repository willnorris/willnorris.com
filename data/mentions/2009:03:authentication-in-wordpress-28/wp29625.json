{
  "type": "entry",
  "author": {
    "type": "card",
    "name": "Martin Atkins",
    "url": "http://mart.degeneration.co.uk/",
    "photo": "https://www.gravatar.com/avatar/a0b347907bfaf05694805210ec595d6c?s=256&d=404"
  },
  "url": "http://mart.degeneration.co.uk/",
  "published": "2009-03-11T05:06:13-07:00",
  "content": {
    "html": "(This comment turned into a bit of a brain dump, so I apologise in advance.)\r\n\r\nWhen I attacked this problem in a different system (which is unfortunately not open source) I solved it by identifying three separate pluggable components:\r\n\r\n* Authentication frontend. This is responsible for showing some UI, which is usually a HTML form. This is nothing more than a standard action, controller, or whatever such things are called in your framework that happens to call into the \"create session\" and \"destroy session\" methods on a particular configured session manager.\r\n\r\n* Session manager. On each request, this component is asked \"who is the remote user?\" and responds with a user object. It also can optionally provide \"start session\" and \"end session\" methods if it supports session state, but since HTTP auth is stateless anything HTTP auth like does not provide these methods. This was implemented as a plugin class with a specific interface.\r\n\r\n* Username/password backend. Used by frontends that deal in usernames and passwords (which, in this case, were either a username/password web form or a basic authentication frontend) to actually check a username/password pair, since username/password is a common enough case for it to be worth having an extra layer for. This was again implemented as a plugin class with a specific interface.\r\n\r\nThe default case is a HTML forms username/password-based frontend for logging in, a standard \"ask the user and then close the session\" frontend for logging out, a cookie-based session manager (which supports session state) and a user/password backend that looks at the local DB. You can swap out the user/password backend to support LDAP or whatever.\r\n\r\nTo add OpenID support for end-users, you use an OpenID frontend, which can either replace or supplement the username/password frontend. The rest of the stack remains the same as username/password.\r\n\r\nFor an API that uses OAuth, you use a stateless session manager that can validate OAuth arguments and some other external, OAuth-specific gunk to do the request token endpoint and so on. You don't need any frontend in the traditional sense, but you do need to provide some \"frontend\" to do the OAuth request token endpoint and so forth. Since it's not username/password based, you don't need a username/password backend.\r\n\r\nIt looks like this Wordpress approach conflates the frontend with the session manager, unless I'm missing something. This presumably means that the thing that does the username/password authentication is creating the session cookie and is therefore tightly coupled with the cookie-based authenticator. It's also not obvious to me how I'd implement Basic auth support if the username/password thing can only deal with username/password submitted via an HTML form. Maybe I'm misunderstanding, though.\r\n\r\nOne thing missing from my approach is that in the OAuth case you generally have two authenticated parties: the application that's making the request and the user the request is on behalf of. I didn't ever solve this problem, and I don't think it's really addressed by your solution either unless I'm missing it.\r\n\r\nIt seems like the solution in both cases is to split the concept of the remote user in two; there's the user that's making the request and the user they're acting as. In all except the OAuth case they're the same. It does seem kinda lame to bleed OAuth-specific concepts into the main API, but this would in theory be useful if you wanted to implement some other delegated auth scheme.",
    "text": ""
  },
  "wm-id": "29625",
  "wm-property": "in-reply-to",
  "in-reply-to": "https://willnorris.com/2009/03/authentication-in-wordpress-28/"
}